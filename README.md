# The Birthday Presents Party And Atmospheric Temperature Reading Module
* To run problem 1 (Minotaur Birthday Party): `javac MinotaurThanksYou.java && java MinotaurThanksYou <num_presents> <num_servants> <-p>`
    - Where these are all optional arguments dictating the number of presents, the number of servants (threads), and if you are wanting to see the steps each servant takes.
    - You can omit the first 2 args and still include *-p*
    - If *num_presents* and *num_servants* are both included, they must be in the exact order indicated
    - You can omit *num_servants* if you just want to change the *num_presents*
    (I know, a lot of rules...)
    - Defaults for this program are num_presents = 500,000 and num_servants = 4.
* To run problem 2 (Temperature Readings): `javac AtmosphericTemperatureReport.java && java AtmosphericTemperatureReport <time_scale> <num_reports>`
    - These are optional arguments where *time_scale* (must be > 0) dictates how much you want to scale the times which I've defined below, and *num_reports* is how many hourly reports you want generated by the temperature module.
    - Scale:
        - Hourly Reports -> Default to reports every 30 seconds.
        - Minute scans by Scanner -> Default to a scan every half a second.
        - The 10-minute interval for biggest temp difference within each report -> Default to a 5 second interval.
    - *time_scale* is a double, so you can scale with t > 0.0

## Problem 1: The Birthday Presents Party
The Minotaur’s birthday party was a success. The Minotaur received a lot of presents from his guests. The next day he decided to sort all of his presents and start writing“Thank you” cards. Every present had a tag with a unique number that was associated with the guest who gave it. As the Minotaur was impatient to get this task done quickly, he instructed his servants not to wait until all of the presents from the unordered bag are placed in the chain of linked and ordered presents. Instead, every servant was asked to alternate adding gifts to the ordered chain and writing “Thank you” cards. Design and implement a concurrent linked-list that can help the Minotaur’s 4 servants with this task. In your test, simulate this concurrent “Thank you” card writing scenario by dedicating 1 thread per servant and assuming that the Minotaur received 500,000 presents from his guests.

### Approach and Proof
The approach was straight forward in the way that we were essentially told in what to implement for this problem, the only deviation was the strategy to employ while handling this Linked List of Presents. I used a `ConcurrentLinkedList` to ensure thread-safety using an `AtomicReference` for the head pointer to the list. When editing anything in the list, such as adding or removing, I used an `ReentrantLock` when adding or removing from the Linked List so that no thread will ever get a null pointer exception when working with it. Without using the lock, if a thread were to remove something as another thread tried to access it that could result in a null pointer exception depending on the thread order, so this lock ensures that this won't happen. Along with the `ConcurrentLinkedList`, the threads are also sharing the unordered (really shuffled) bag of presents using a `synchronized` code block, where they each with take the first present out of the bag and add it to the list.

In terms of the approach of how the threads operate, first they will take a present out of the unordered bag and add it to the linked list, then if they were ordered by the minotaur they would check for a specific present by tag - if it exists, they remove it, otherwise they will just remove the first present from the list. They continue this until the unordered bag of presents is empty, this strategy works as if each thread linearly adds one present then removes one present, when the bag is empty so is the linked list.

### Experimental Evaluation And Efficiency Analysis
When I first tried implementing this program, I tried doing the exact steps that was described in the problem (not seen here), and I ran into multiple issues. The first I sometimes ended up with more presents than "Thank You's", and the second sometimes the threads got hung up on trying to find and/or remove a present causing an infinite loop in one of the threads and the others getting caught up since the list was locked. I was trying to think of numerous ways in fixing the holes in the strategy, but ultimately came up with this linear approach you see in the code.

In terms of efficiency, this concurrent linked list allows multiple threads to perform operations concurrently improving the efficiency of the overall program. The use of the `ReentrantLock` minimizes contention and allows for this efficient concurrent access to the list. The linear implementation I have distributes the workload among the threads by allowing each thread to process a portion of the presents from the unordered bag.

## Problem 2: Atmospheric Temperature Reading
You are tasked with the design of the module responsible for measuring the atmospheric temperature of the next generation Mars Rover, equipped with a multicore CPU and 8 temperature sensors. The sensors are responsible for collecting temperature readings at regular intervals and storing them in shared memory space. The atmospheric temperature module has to compile a report at the end of every hour, comprising the top 5 highest temperatures recorded for that hour, the top 5 lowest temperatures recorded for that hour, and the 10-minute interval of time when the largest temperature difference was observed. The data storage and retrieval of the shared memory region must be carefully handled, as we do not want to delay a sensor and miss the interval of time when it is supposed to conduct temperature reading. Design and implement a solution using 8 threads that will offer a solution for this task. Assume that the temperature readings are taken every 1 minute. In your solution, simulate the operation of the temperature reading sensor by generating a random number from -100F to 70F at every reading.

### Approach and Proof
I've set up three classes for the Rover: `TemperatureSensor`, `TemperatureReading`, and last the `TemperatureModule`. The `TemperatureSensor` classes all share a common storage called `temperatureReadings` which is a list of `TemperatureReading`. They safely add each reading to this list through a synchronized block ensuring each thread gets exclusive access to it throughout this process. When the `TemperatureSensor` creates a `TemperatureReading` it creates a random temperature within the range that was specified within the problem along with the timestamp in milliseconds of when it was "scanned". The `TemperatureModule` sleeps for a specified time defined by the `reportInterval` which can be scaled where it accesses the shared memory, creates a copy, then clears it for the next hour of temperature readings all with exclusive access to this list with a `synchronized` block, then goes on and makes it reports while the scanners continue to do their tasks. 

In the main method, I have also simulated the monitoring period to determine when the Rover's task of reading the atmospheric temperatures is done. Using an `AtomicBoolean` called `stopSensors` to get the threads to finish their tasks and join back up the end the program.

### Experimental Evaluation and Efficiency Analysis
To experiment with the number of sensors, or even number of reports, is difficult due to the tasks of each thread which is just recording data in set amounts of time. However, I did implement the possibility of scaling the time due to reasons such as TAs needing to grade this, and needing to be able to test if the program is working properly myself, I can make the time each thread records temperatures and time-interval necessities such as the 10-minute span of temperature difference or the hourly reports different in each run. I can make it quick, or I can bring it up to times described in the problem.

In terms of efficiency, this program utilizes multiple temperature sensors through threads to collect readings concurrently using `synchronized` blocks of codes to ensure exclusive access to the shared memory when they are to add a new reading to the list. This minimizes contention and ensures thread-safety. Adding my time scale factor can allow for faster or longer simulation results with adjusting the sensor intervals, report intervals, monitoring duration, etc. We manage memory in an efficient manner due to clearing the list of readings after every "hour" minimizing the space complexity of the program as well.
